{"version":3,"sources":["../src/index.ts"],"names":["OryProvider","options","_a","client","request","revocationUrl","params","response","ServerError","registrationUrl","data","OAuthClientInformationFullSchema","acc","error","clientId","res","_b","state","targetUrl","searchParams","resolve","_client","_authorizationCode","authorizationCode","codeVerifier","OAuthTokensSchema","refreshToken","scopes","token","introspection"],"mappings":"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","file":"index.js","sourcesContent":["// Copyright Â© 2025 Ory Corp\n\nimport { OAuthRegisteredClientsStore } from '@modelcontextprotocol/sdk/server/auth/clients.js';\nimport { ServerError } from '@modelcontextprotocol/sdk/server/auth/errors.js';\nimport {\n  AuthorizationParams,\n  OAuthServerProvider,\n} from '@modelcontextprotocol/sdk/server/auth/provider.js';\nimport { AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js';\nimport {\n  OAuthClientInformationFull,\n  OAuthClientInformationFullSchema,\n  OAuthTokenRevocationRequest,\n  OAuthTokensSchema,\n  OAuthTokens,\n} from '@modelcontextprotocol/sdk/shared/auth.js';\nimport * as crypto from 'crypto';\nimport { Response } from 'express';\n\nexport type OryEndpoints = {\n  authorizationUrl: string;\n  tokenUrl: string;\n  revocationUrl?: string;\n  registrationUrl?: string;\n};\n\nexport type HydraClient = {\n  client_id: string;\n  redirect_uris: string[];\n};\n\nexport type OryProviderType = 'network' | 'hydra';\n\nexport type BaseOryOptions = {\n  endpoints: OryEndpoints;\n  providerType: OryProviderType;\n  hydraAdminUrl?: string;\n  hydraApiKey?: string;\n  networkProjectUrl?: string;\n  networkProjectApiKey?: string;\n};\n\nexport type OryOptions = BaseOryOptions;\n\nexport class OryProvider implements OAuthServerProvider {\n  protected readonly _endpoints: OryEndpoints;\n  protected readonly _providerType: OryProviderType;\n  protected readonly _hydraAdminUrl?: string;\n  protected readonly _hydraApiKey?: string;\n  protected readonly _networkProjectUrl?: string;\n  protected readonly _networkProjectApiKey?: string;\n\n  skipLocalPasswordGrant = false;\n  skipLocalPkceValidation = true;\n\n  revokeToken?: (\n    client: OAuthClientInformationFull,\n    request: OAuthTokenRevocationRequest\n  ) => Promise<void>;\n\n  constructor(options: OryOptions) {\n    this._endpoints = options.endpoints;\n    this._providerType = options.providerType;\n    this._hydraAdminUrl = options.hydraAdminUrl;\n    this._hydraApiKey = options.hydraApiKey;\n    this._networkProjectUrl = options.networkProjectUrl;\n    this._networkProjectApiKey = options.networkProjectApiKey;\n\n    if (options.endpoints?.revocationUrl) {\n      this.revokeToken = async (\n        client: OAuthClientInformationFull,\n        request: OAuthTokenRevocationRequest\n      ): Promise<void> => {\n        const revocationUrl = this._endpoints.revocationUrl;\n\n        if (!revocationUrl) {\n          throw new Error('No revocation endpoint configured');\n        }\n\n        const params = new URLSearchParams();\n        params.set('token', request.token);\n        params.set('client_id', client.client_id);\n        if (client.client_secret) {\n          params.set('client_secret', client.client_secret);\n        }\n        if (request.token_type_hint) {\n          params.set('token_type_hint', request.token_type_hint);\n        }\n\n        const response = await fetch(revocationUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n          },\n          body: params.toString(),\n        });\n\n        if (!response.ok) {\n          throw new ServerError(`Token revocation failed: ${response.status}`);\n        }\n      };\n    }\n  }\n\n  get clientsStore(): OAuthRegisteredClientsStore {\n    const registrationUrl = this._endpoints.registrationUrl;\n    return {\n      getClient: this.getClient.bind(this),\n      ...(registrationUrl && {\n        registerClient: async (\n          client: OAuthClientInformationFull\n        ): Promise<OAuthClientInformationFull> => {\n          const response = await fetch(registrationUrl, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(client),\n          });\n\n          if (!response.ok) {\n            throw new ServerError(`Client registration failed: ${response.status}`);\n          }\n\n          const data = (await response.json()) as Record<string, unknown>;\n          return OAuthClientInformationFullSchema.parse(data);\n        },\n      }),\n    };\n  }\n\n  private async fetchClients(): Promise<OAuthClientInformationFull[]> {\n    if (this._providerType === 'hydra') {\n      if (!this._hydraAdminUrl) {\n        throw new Error('Hydra admin URL is required for hydra provider type');\n      }\n      const response = await fetch(`${this._hydraAdminUrl}/admin/clients`, {\n        headers: {\n          Authorization: `Bearer ${this._hydraApiKey}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to list OAuth2 clients: ${response.statusText}`);\n      }\n\n      const clients = (await response.json()) as unknown[];\n      return clients.map((client: unknown) => OAuthClientInformationFullSchema.parse(client));\n    }\n\n    if (this._providerType === 'network') {\n      if (!this._networkProjectUrl) {\n        throw new Error('Network project URL is required for network provider type');\n      }\n      const response = await fetch(`${this._networkProjectUrl}/admin/clients`, {\n        headers: {\n          Authorization: `Bearer ${this._networkProjectApiKey}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to list OAuth2 clients: ${response.statusText}`);\n      }\n\n      const clients = (await response.json()) as unknown[];\n      return clients.map((client: unknown) => OAuthClientInformationFullSchema.parse(client));\n    }\n\n    throw new Error('Invalid provider type');\n  }\n\n  async listOAuth2Clients(): Promise<Record<string, OAuthClientInformationFull>> {\n    try {\n      const clients = await this.fetchClients();\n      return clients.reduce(\n        (acc: Record<string, OAuthClientInformationFull>, client: OAuthClientInformationFull) => {\n          acc[client.client_id] = client;\n          return acc;\n        },\n        {}\n      );\n    } catch (error) {\n      console.error('Error listing OAuth2 clients:', error);\n      throw error;\n    }\n  }\n\n  async getClient(clientId: string): Promise<OAuthClientInformationFull | undefined> {\n    try {\n      const clients = await this.listOAuth2Clients();\n      return clients[clientId];\n    } catch (error) {\n      console.error('Error getting client:', error);\n      throw error;\n    }\n  }\n\n  async authorize(\n    client: OAuthClientInformationFull,\n    params: AuthorizationParams,\n    res: Response\n  ): Promise<void> {\n    let state = '';\n    if (!params.state) {\n      state = crypto.randomBytes(32).toString('hex');\n      params.state = state;\n    }\n\n    if (params.scopes?.length === 0) {\n      params.scopes = ['ory.admin'];\n    }\n\n    // Start with required OAuth parameters\n    const targetUrl = new URL(this._endpoints.authorizationUrl);\n    const searchParams = new URLSearchParams({\n      client_id: client.client_id,\n      response_type: 'code',\n      redirect_uri: params.redirectUri,\n      code_challenge: params.codeChallenge,\n      code_challenge_method: 'S256',\n    });\n\n    // Add optional standard OAuth parameters\n    if (params.state) searchParams.set('state', params.state);\n    if (params.scopes?.length) searchParams.set('scope', params.scopes.join(' '));\n\n    targetUrl.search = searchParams.toString();\n    // This below line is just a hack to make the function async as lint will complain\n    await new Promise(resolve => setTimeout(resolve, 100));\n    res.redirect(targetUrl.toString());\n  }\n\n  async challengeForAuthorizationCode(\n    _client: OAuthClientInformationFull,\n    _authorizationCode: string\n  ): Promise<string> {\n    // In a proxy setup, we don't store the code challenge ourselves\n    // Instead, we proxy the token request and let the upstream server validate it\n    // This below line is just a hack to make the function async as lint will complain\n    await new Promise(resolve => setTimeout(resolve, 100));\n    return '';\n  }\n\n  async exchangeAuthorizationCode(\n    client: OAuthClientInformationFull,\n    authorizationCode: string,\n    codeVerifier?: string\n  ): Promise<OAuthTokens> {\n    const params = new URLSearchParams({\n      grant_type: 'authorization_code',\n      client_id: client.client_id,\n      code: authorizationCode,\n      redirect_uri: client.redirect_uris[0],\n    });\n\n    if (client.client_secret) {\n      params.append('client_secret', client.client_secret);\n    }\n\n    if (codeVerifier) {\n      params.append('code_verifier', codeVerifier);\n    }\n\n    const response = await fetch(this._endpoints.tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: params.toString(),\n    });\n\n    if (!response.ok) {\n      throw new ServerError(`Token exchange failed: ${response.status}`);\n    }\n\n    const data = (await response.json()) as Record<string, unknown>;\n    return OAuthTokensSchema.parse(data);\n  }\n\n  async exchangeRefreshToken(\n    client: OAuthClientInformationFull,\n    refreshToken: string,\n    scopes?: string[]\n  ): Promise<OAuthTokens> {\n    const params = new URLSearchParams({\n      grant_type: 'refresh_token',\n      client_id: client.client_id,\n      refresh_token: refreshToken,\n    });\n\n    if (client.client_secret) {\n      params.set('client_secret', client.client_secret);\n    }\n\n    if (scopes?.length) {\n      params.set('scope', scopes.join(' '));\n    }\n\n    const response = await fetch(this._endpoints.tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: params.toString(),\n    });\n\n    if (!response.ok) {\n      throw new ServerError(`Token refresh failed: ${response.status}`);\n    }\n\n    const data = (await response.json()) as Record<string, unknown>;\n    return OAuthTokensSchema.parse(data);\n  }\n\n  private async introspectToken(token: string): Promise<{\n    active: boolean;\n    client_id: string;\n    scope?: string;\n    exp: number;\n  }> {\n    if (this._providerType === 'hydra') {\n      if (!this._hydraAdminUrl) {\n        throw new Error('Hydra admin URL is required for hydra provider type');\n      }\n      const response = await fetch(`${this._hydraAdminUrl}/admin/oauth2/introspect`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          Authorization: `Basic ${Buffer.from(token).toString('base64')}`,\n        },\n        body: new URLSearchParams({\n          token,\n          token_type_hint: 'access_token',\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Token introspection failed: ${response.statusText}`);\n      }\n\n      return response.json() as Promise<{\n        active: boolean;\n        client_id: string;\n        scope?: string;\n        exp: number;\n      }>;\n    }\n\n    if (this._providerType === 'network') {\n      if (!this._networkProjectUrl) {\n        throw new Error('Network project URL is required for network provider type');\n      }\n      const response = await fetch(`${this._networkProjectUrl}/admin/oauth2/introspect`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          Authorization: `Bearer ${this._networkProjectApiKey}`,\n        },\n        body: new URLSearchParams({\n          token,\n          token_type_hint: 'access_token',\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Token introspection failed: ${response.statusText}`);\n      }\n\n      return response.json() as Promise<{\n        active: boolean;\n        client_id: string;\n        scope?: string;\n        exp: number;\n      }>;\n    }\n\n    throw new Error('Invalid provider type');\n  }\n\n  async verifyAccessToken(token: string): Promise<AuthInfo> {\n    try {\n      const introspection = await this.introspectToken(token);\n\n      if (!introspection.active) {\n        throw new Error('Token is not active');\n      }\n\n      const clients = await this.listOAuth2Clients();\n      const client = clients[introspection.client_id];\n\n      if (!client) {\n        throw new Error('Token client ID mismatch');\n      }\n\n      return {\n        token,\n        clientId: introspection.client_id,\n        scopes: introspection.scope?.split(' ') || [],\n        expiresAt: introspection.exp,\n      };\n    } catch (error) {\n      console.error('Token verification failed:', error);\n      throw error;\n    }\n  }\n}\n"]}